Hello Practicing Rubyist!

Your subscription helps make it possible for me to spend most of my 
time working on Mendicant University as well as several other projects 
that benefit the Ruby community. Thanks so much for being a part of
this!

## General Information

You may be interested in the following resources, if you haven't seen 
them already. 

  Archives of all issues + discussions: 
  http://practicingruby.com/community

  Information for new subscribers:
  http://practicingruby.com/community/welcome

  Link dumps, essays, and updates about MU and my OSS contributions:
  http://majesticseacreature.com

NOTE: For the time being, these messages will be sent in plain text
format and are best viewed with a fixed-width font. If you would
prefer HTML formatted emails instead, please let me know.

## Issue 2.1: Ways to Load Code 

There are many ways to load Ruby code, and that has lead to confusion 
over the years. In this article, I will give you the back story behind 
several conventions seen in the wild and share some stories about how I 
use those conventions in my own code.

The topic of code loading breaks up naturally into two sub-topics: 
loading code within your own project, and loading code from third party 
libraries. People tend to struggle more with loading code properly 
within their own projects than they do with loading code from third 
party libraries, and so that's what I'll focus on exclusively in this 
issue. That said, there is certainly room for a second article on 
dealing with external dependencies, so be sure to let me know if that 
interests you.

For now, let's focus on the basic mechanics of load(), auto_load(), 
require(), and require_relative(). We'll discuss how they work and then 
think about how they can be used within your own projects.

### Kernel#load()

Suppose we have a file called calendar.rb that contains the code shown 
below. 

    class Calendar
      def initialize(month, year)
        @month = month
        @year  = year
      end

      # A simple wrapper around the *nix cal command.
      def to_s
        IO.popen(["cal", @month.to_s, @year.to_s]) { |io| io.read }
      end
    end

    puts Calendar.new(8, 2011)

Given an absolute path to this file, the contents will be loaded and 
then executed immediately. 

    >> load "/Users/seacreature/devel/practicing-ruby-2/calendar.rb"
        August 2011
    Su Mo Tu We Th Fr Sa
        1  2  3  4  5  6
     7  8  9 10 11 12 13
    14 15 16 17 18 19 20
    21 22 23 24 25 26 27
    28 29 30 31

I can also just specify a path relative to my current working directory, 
and get the same results. That means that if calendar.rb is in the same 
directory I invoked my irb session from, I'm able to call load() in the 
manner shown below.

    >> load "./calendar.rb"
        August 2011
    Su Mo Tu We Th Fr Sa
        1  2  3  4  5  6
     7  8  9 10 11 12 13
    14 15 16 17 18 19 20
    21 22 23 24 25 26 27
    28 29 30 31

An interesting thing about load() is that it does not do any checks to 
see if it has already loaded a file, and will happily re-load and 
re-execute a file each time you tell it to. That means that in practice, 
the implementation of load() is functionally similar to the code shown 
below. Go ahead and try it out if you'd like.

    def fake_load(file)
      eval File.read(file)
      true
    end

The main benefit of indiscriminately re-loading and re-executing code is 
that you can make changes to your files and then load() them again 
within a single session, without having to restart the program that's 
loading the code. So for example, if we changed calendar.rb to output
August 2012 instead of August 2011, we could just load it again without 
restarting irb. But we'd also be greeted with some warnings in the process.

    >> load "./calendar.rb"
    /Users/seacreature/devel/practicing-ruby-2/calendar.rb:2: 
    warning: method redefined; discarding old initialize
    /Users/seacreature/devel/practicing-ruby-2/calendar.rb:2: 
    warning: previous definition of initialize was here
    /Users/seacreature/devel/practicing-ruby-2/calendar.rb:8: 
    warning: method redefined; discarding old to_s
    /Users/seacreature/devel/practicing-ruby-2/calendar.rb:8:
    warning: previous definition of to_s was here
        August 2012
    Su Mo Tu We Th Fr Sa
              1  2  3  4
     5  6  7  8  9 10 11
    12 13 14 15 16 17 18
    19 20 21 22 23 24 25
    26 27 28 29 30 31

If we remember that Ruby classes and modules are permanently open to 
modification, these warnings should make a lot of sense. The first time 
we called load(), it defined the initialize() and to_s() methods for 
the Calendar class. The second time we called load(), that class and 
its methods already existed, so it redefined them. This is not 
necessarily a sign of a bug, but Ruby is smart enough to know that it 
might be something you should look at.

Ultimately, these warnings are Ruby telling you that there is probably a 
better way for you to do what you're trying to do. One interesting way 
to get around the problem is to use Kernel#load()'s wrap functionality. 
Rather than telling you directly how it works, I'd rather show you by 
example and see if you can guess what's going on.

Suppose we kill our irb session and fire up a new one, and we're now 
back to a blank slate. We then run the following code and see the
familiar calendar output.

    >> load "./calendar.rb", true
        August 2012
    Su Mo Tu We Th Fr Sa
              1  2  3  4
     5  6  7  8  9 10 11
    12 13 14 15 16 17 18
    19 20 21 22 23 24 25
    26 27 28 29 30 31 

Then, we decide that we want to look a little deeper into the future,
so that we know what to plan for in AD 2101. We reload the code using the 
same command as before.

    >> load "./calendar.rb", true
        August 2101
    Su Mo Tu We Th Fr Sa
        1  2  3  4  5  6
     7  8  9 10 11 12 13
    14 15 16 17 18 19 20
    21 22 23 24 25 26 27
    28 29 30 31

This time, we don't see any warnings, so obviously something has 
changed. Here's a clue.

    >> Calendar
    NameError: uninitialized constant Object::Calendar
      from (irb):2
      from /.../.rvm/rubies/ruby-1.9.2-p180/bin/irb:16:in `<main>'

Surely the Calendar class must have been defined *somewhere*, because 
the program worked as expected. So is going on here? Take a look 
at the following code and it should give you a better picture 
if you're feeling stumped.

    def fake_load(file)
      Module.new.module_eval(File.read(file))
      true
    end

In this implementation, our approximation of load() is evaluating the 
loaded code in the context of an anonymous module, which essentially 
wraps everything in a name space. This prevents any of the constants 
defined in the loaded code from being defined within the global 
namespace, including any class or module definitions.

The existence of this option is a hint that while load() is suitable for 
code loading, it is more geared up for implementing customized 
runners for Ruby code than it is for simply loading the classes
and modules in your projects. That means that if you've been using 
load() on a daily basis, you might be using the wrong tool for the 
job at least some of the time. It should be clear by the end of this
article why that is the case.

Now that we have looked at the most simple code loading behavior Ruby
has to offer, we will jump straight into the deepend and explore one
of its most complex options: loading code on demand via
Kernel#autoload.

### Kernel#autoload()

Whether you've used it explicitly in your own projects or not, the 
concept of automatically loading code on demand should be familiar to 
anyone familiar with Rails. In Rails, none of the classes or modules 
you define get loaded until the first time they are referenced in 
your running program. There are two main benefits to this: faster 
startup time, and delayed loading of optional dependencies.

Rails uses its own customized code to accomplish this, but the basic 
idea is similar to what can be done with Ruby's autoload() method. To 
illustrate how autoload() works, we can revisit our Calendar class that 
we began building while discussing load(). This time, we have a file 
called calendar.rb which contains only the definition of the Calendar
class, and not the code which actually calls methods on it.

    class Calendar
      def initialize(month, year)
        @month = month
        @year  = year
      end

      # A simple wrapper around the *nix cal command.
      def to_s
        IO.popen(["cal", @month.to_s, @year.to_s]) { |io| io.read }
      end
    end

The following irb session demonstrates the behavior of autoload(). 

    >> autoload(:Calendar, "./calendar.rb") #1
    => nil
    >> defined?(Calendar)                   #2
    => nil
    >> puts Calendar.new(8,2011)            #3
        August 2011
    Su Mo Tu We Th Fr Sa
        1  2  3  4  5  6
     7  8  9 10 11 12 13
    14 15 16 17 18 19 20
    21 22 23 24 25 26 27
    28 29 30 31

    => nil
    >> defined?(Calendar)                   #4
    => "constant"

In our first step, we set up the autoload() hook, instructing Ruby to 
load the file calendar.rb at the time that the first constant lookup 
happens for the Calendar constant. In the second step, we check to ensure 
that autoload() does not actually load the file for you automatically by 
verifying that Calendar has not yet been defined. Then in our third step 
we build and output our Calendar. Lastly, we see that the constant is 
now defined.

This exposes us to some cool Ruby voodoo while also raising a lot of 
questions. It may help to approximate how autoload() might be 
implemented, to wrap your head around the idea. While the code below is 
evil and should never be used for anything but educational purposes, it 
simulates the load on demand behavior nicely.

    $load_hooks = {}

    module Kernel
      def fake_autoload(constant_name, file_name)
        $load_hooks[constant_name] = file_name
      end
    end

    def Object.const_missing(constant)
      load $load_hooks[constant]
      const_get(constant)
    end

    fake_autoload :Calendar, "./calendar.rb"
    p defined?(Calendar)
    puts Calendar.new(8,2011)
    p defined?(Calendar)

After reading the above and playing with it a bit, remember the 
dependency on const_missing() and forget pretty much everything else 
about the implementation. The real autoload() handles a lot more 
cases than this trivial example gives it credit for.

With the const_missing() dependency in mind, try to guess what will
happen when the following code is run.

    class Calendar; end

    autoload :Calendar, "./calendar.rb"
    p defined?(Calendar)
    puts Calendar.new(8,2011)
    p defined?(Calendar)

If you guessed that it didn't output a nicely formatted calendar, you 
guessed correctly. Below you can see that when I run this script, all
the code in calendar.rb never gets loaded and so the default
Object#initialize and Object#to_s are being called instead.

    "constant"
    #<Calendar:0x0000010086d6b0>
    "constant"

Because autoload() does not check to see whether a constant is already 
defined when it registers its hook, you do not get an indication that 
the calendar.rb file was never loaded until you actually try to use
functionality defined in that file. This means that autoload() is only 
safe to use when there is a single, uniform place where a constant 
is meant to be defined, it cannot be used to incrementally build up 
class or module definitions from several different source files.

This sort of rigidity is frustrating, because unlike load() which does 
not care how or where you define your code, autoload() is much more 
opinionated. What we've seen here is a single example of the constraints 
it puts on you, but it is easy to imagine other scenarios in which 
autoload() can feel like a brittle way to load code. I'll leave it up to 
you to try to figure out some of those issues, but feel free to ask me
for some hints if you get stumped.

In the context of Rails, particularly when working in development mode 
in which the whole environment gets reloaded on every request, some form 
of autoload makes sense. However, outside of that environment, the 
drawbacks of autoload() tend to outweigh the benefits, and so most
Ruby projects tend to avoid it entirely by making heavy use of require().

### Kernel#require()

If you've written any code at all outside of Rails, odds are you've used 
require() before. It is actually quite similar to load(), but has a few 
additional features that come in handy. To illustrate how require() 
works, we will revisit our original calendar.rb file, the one that had a 
bit of code to be executed in the end of it.

    class Calendar
      def initialize(month, year)
        @month = month
        @year  = year
      end

      # A simple wrapper around the *nix cal command.
      def to_s
        IO.popen(["cal", @month.to_s, @year.to_s]) { |io| io.read }
      end
    end

    puts Calendar.new(8, 2011)

If we attempt to load this code twice via require(), we immediately see 
an important way that it differs from load().

    >> require "./calendar.rb" #1
        August 2011
    Su Mo Tu We Th Fr Sa
        1  2  3  4  5  6
     7  8  9 10 11 12 13
    14 15 16 17 18 19 20
    21 22 23 24 25 26 27
    28 29 30 31

    => true
    >> require "./calendar.rb" #2
    => false

When I ran require() the first time, the familiar calendar output greeted 
me, and then the function returned a true value. The second time I ran 
it, nothing happened and the function returned false. This is a feature, 
and not a bug. The code below is a crude approximation of what is going 
on under the hood in require().

    $LOADED_BY_FAKE_REQUIRE = []

    def fake_require(file)
      full_path = File.expand_path(file)
      return false if $LOADED_BY_FAKE_REQUIRE.include?(full_path)

      load full_path
      $LOADED_BY_FAKE_REQUIRE << full_path

      return true
    end

This behavior ensures that each file loaded by require() is loaded 
exactly once, even if the require() calls appear in many places. This 
means that updates to those files will take effect after they have been 
loaded once. While this makes require() less suitable than load() for 
quick exploratory code loading, it does prevent programs from needlessly 
reloading the same code again and again, similar to how autoload() works 
once a constant has been loaded.

Another interesting property of require() is that you can omit the file 
extension when loading your code. This means that require("./calendar") 
will work just as well as require("./calendae.rb"). While this may seem 
like a small feature, the reason it exists is because Ruby can actually 
load more than just Ruby files. When you omit an extension on a file 
loaded with require, it will attempt to load the file with the ".rb" 
extension first, but then will cycle through the file extensions used by 
C extensions as well, such as ".so", ".o", and ".dll". While somewhat of 
an obscure note, it's one that we often take for granted when we load 
certain standard libraries or third party gems. This behavior is
another detail which separates require() from load(), as the latter 
can only work with explicit file extensions.

The main benefit of using require() is that it gives the explicit, 
predictable loading behavior of load() with the caching functionality of 
autoload(). It also feels natural for those who use RubyGems, since the 
standard way of loading libraries distributed as gems is via the patched 
version of Kernel#require() that RubyGems provides.

While using require() will take you far, it suffers from a pretty 
irritating problem that load() and autoload() also share with the way it 
looks up files. The require_relative() is meant to solve that problem, 
so we'll take a look at it now.

### Kernel#require_relative()

Each time I referenced files using a relative path in the previous 
examples, I wrote the path to explicitly reference the current working 
directory. If you're used to using Ruby 1.8, this may come as a surprise 
to you. If you've been using Ruby 1.9.2, it may or may not appear like 
the natural thing to do. However, now is the time where I confess that 
it's almost always the wrong way to go about things.

Ruby 1.9.2 removes the current working directory from your path by 
default for security reasons. That means that in our previous example, 
if we attempted to write require("calendar") instead of 
require("./calendar"), it would fail on Ruby 1.9.2 even if we invoked irb 
in the same folder as the calendar.rb file. Explicitly referencing the 
current working directory works on both Ruby 1.8.7 and Ruby 1.9.2, which 
is why this convention was born. Unfortunately, it is an anti-pattern, 
because it forces us to assume our code will be run from a particular 
place on the file system.

Imagine a more typically directory structure, such as the one shown below.

    lib/
      calendar.rb
      calendar/
        month.rb
        year.rb
    bin/
      calendar.rb

We could have a bin/ruby_calendar.rb that looks like the code below.

    require "lib/calendar"

    case ARGV.size
    when 2
      puts Calendar::Month.new(ARGV[0], ARGV[1])
    when 1
      puts Calendar::Year.new(ARGV[0])
    else
      raise "Invalid arguments"
    end

Similarly, our lib/calendar.rb file might include require calls such
as the ones shown below.

    require "lib/calendar/year"
    require "lib/calendar/month"

Now, if we run bin/speaker.rb from the project root, things will work as 
expected.

    $ ruby bin/ruby_calendar.rb 2011
    # ...

But if we ran this file from any other directory, it'd fail to work as 
expected, because the relative paths would be evaluated relative to 
wherever you executed the files from, not relative to where the files 
live on the file system. That means if you execute ruby_calendar.rb in 
the bin/ folder, it would look for a file called bin/lib/calendar.rb.

One way to solve this problem is to use the same mechanism that the Ruby 
standard library and RubyGems uses; you can modify the loadpath.

In bin/ruby_calendar.rb, we rewrite our code to match what is shown below.

    $LOAD_PATH.unshift("#{File.dirname(__FILE__)}/../lib")
    require "calendar"

    case ARGV.size
    when 2
      puts Calendar::Month.new(ARGV[0], ARGV[1])
    when 1
      puts Calendar::Year.new(ARGV[0])
    else
      raise "Invalid arguments"
    end


Now, because we've added the lib/ folder to the lookup path for all 
require() calls in our application, we can modify lib/calendar.rb to 
match what is shown below.

    require "calendar/year"
    require "calendar/month"

This makes it possible to run the ruby_calendar.rb program from any 
location within the file system, as long as we tell ruby where to 
find it. That means you can run it directly from within 
the bin/ folder, or even with an absolute path.

    # NOTE: this is common in cron jobs.
    $ ruby /Users/seacreature/devel/ruby_calendar/bin/ruby_calendar.rb

This approach works, and was quite common in Ruby for some time. Then, 
people began to get itchy about it, because it really is a big hammer. 
It effectively adds an entire folder to the $LOAD_PATH, giving Ruby one 
more place it has to look on every require, and possibly leading to 
unexpected naming conflicts between libraries.

The solution to that problem is not to mess with the $LOAD_PATH in your 
code. That means that you either expect that the $LOAD_PATH will be 
properly set by the -I flag when you invoke ruby or irb, or that you 
have to write code that dynamically determines the proper relative paths 
to require based on your current working directory. The latter approach 
requires less effort from the end user, but makes your code ugly. Below 
you'll see what people resorted to on Ruby 1.8 before a better solution 
came along.

    # bin/ruby_calendar.rb
    require "#{File.dirname(__FILE__)}/../lib/calendar"

    case ARGV.size
    when 2
      puts Calendar::Month.new(ARGV[0], ARGV[1])
    when 1
      puts Calendar::Year.new(ARGV[0])
    else
      raise "Invalid arguments"
    end

    # lib/speaker.rb
    require "#{File.dirname(__FILE__)}/calendar/year"
    require "#{File.dirname(__FILE__)}/calendar/month"

Using this approach, you do not add anything to the $LOAD_PATH, but 
instead dynamically build up relative paths by referencing the __FILE__ 
variable and getting a path to the directory it's in. This code will 
evaluate to different values depending on where you run it from, but in 
the end, the right path will be produced and things will just work.

Predictably, people took efforts to hide this sort of ugliness behind 
helper functions, and one such function eventually got adopted into Ruby 
1.9. That helper is predictably called require_relative(). Using 
require_relative(), we can simplify our calls significantly, while 
preserving the 'don't touch the $LOAD_PATH variable' ethos.

    # bin/ruby_say.rb
    require_relative "../lib/calendar"

    case ARGV.size
    when 2
      puts Calendar::Month.new(ARGV[0], ARGV[1])
    when 1
      puts Calendar::Year.new(ARGV[0])
    else
      raise "Invalid arguments"
    end

    # lib/speaker.rb
    require_relative "calendar/year"
    require_relative "calendar/month"

This looks and feels the way that we'd like to think require() would 
work. The files we reference are relative to the file in which the 
actual calls are made, rather than the folder in which the script was 
executed in. For this reason, it is a much better approach than pretty 
much anything we've shown so far.

Of course, it is not a perfect solution. In some cases, it does not work 
as expected, such as in Rackup files. Additionally, because it's a Ruby 
1.9 feature, it's not built into Ruby 1.8.7. The former cannot be worked 
around, but the latter can be. I'll go into a bit more detail about both 
of these issues in the recommendations section that's coming up right now.

### Conventions and Recommendations

If you remember one thing from this article, it's that whenever it's 
possible to use require_relative() and there isn't an obviously better 
solution in your particualr sitaution, it's probably the right tool 
to reach for. It has the least amount of dark corners and pretty much 
just works.

That having been said, please take my advice with a grain of salt. I no 
longer actively maintain any Ruby 1.8 applications, nor do I have to
deal with code that must run on both Ruby 1.8 and 1.9. If I were in
those shoes again, I'd probably weight out four different possible
way of approaching things:

1) explicitly coding requires using the File.dirname(__FILE__) hack
2) writing my own require_relative implementation leaning on the above
   hack that only gets defined if require_relative isn't already
   implemented.
3) Adding a dependency for Ruby 1.8 only on the require_relative gem
4) Assuming that $LOAD_PATH is set for me via the -I flag on execution,
   or some other means, and then just writing ordinary require calls
   relative to the lib/ folder in my project

I can't give an especially good picture of when I'd pick one of those 
options over the other, since it's been about a year since I've last had 
to think about it. But any of those four options seem like at least 
reasonable ideas. I would NOT use the common but painfully ugly
require("./file_in_the_working_dir.rb") hack in any code that 
I expected to use for anything more than a spike or demonstration.

Whether using require_relative() explicitly, or one of the workarounds
listed above, I like to use some form of relative require whenever I
can. Occasionally, I do use load(), particularly in spikes where 
I want to  reload files into an irb session without restarting irb. 
But I don't think that load() ends up in production code of mine unless
there is a very good reason to use it. Some possible good reasons
would be if I was  building some sort of script runner, such as what 
you could find in  Rails when it reloads your development environment 
or in autotest. In the autotest case in particular in which your test 
files are reloaded each time you make an edit to any of your files 
in your project, it seems that using load() with its obscure second
parameter is a good idea. But these are not tools I'd expect to be 
building on a daily basis, so load() remains somewhat of an obscure
tool for me..

I never use autoload(). I've just not run into the issues that some 
folks in Rails experience regarding slow startup times of applications 
in any way that has mattered to me. I feel like the various gotchas that 
come along with using autoload() and the strict conventions it enforces 
are not good things to impose on general purpose uses of Ruby. I don't 
know whether I think that it makes sense in to context of Rails or not, 
but that's a very different question than whether it should be used in 
ordinary Ruby applications and libraries. It at least makes some sense 
in Rails, but in most Ruby applications, it does not. The only time I 
might think about looking into autoload() is if I had some sort of 
optional dependency that I wanted to be loaded only on demand. I have 
never actually run into that issue, and I've found the following hack 
provides a way to do optional dependencies that seems to work just fine.

      begin
        require "some_external_dependency"
        require "my_lib/some_feature_that_depends_on_dependency"
      rescue LoadError
        warn "Could not load some_external_dependency."+
             " Some features are disabled"
      end

But really, optional dependencies are things I very rarely need to think 
about. There are valid use cases for them, but unless something is very 
difficult to install, or if your project is specifically meant to wrap 
various mutually exclusive dependencies, I typically will just load up 
all my dependencies whether or not the user ends up using them. This has 
not caused me any problems, but your mileage will certainly vary 
depending on the type of work you are doing.

On a somewhat tangential note, I try to avoid things like dynamic 
require calls where I walk over a file list generated from something 
like Dir.glob() or the like. I also avoid using Bundler.require(), even 
when I use bundler. The reason I avoid these things is because I like to 
be able control exactly what order my files and my dependencies are 
being loaded in. It's possible to not have to worry about this sort of 
thing, but doing so requires a highly disciplined way of organizing your 
code so that files can be loaded independently. But that general opinion 
is possibly the subject of another article, and we've covered enough for
one day :)

## Feedback and Sharing

Hopefully this background story about the various ways to load code 
along with the few bits of advice I've offered in the end here have been 
useful to you. I am happy to answer whatever questions you have, just
leave a comment on this article in the archives. I look forward to 
your feedback!

You can share this article *privately* with anyone, as long as you make 
it clear that this content is from a subscription-based newsletter by 
Gregory Brown which they can sign up for at practicingruby.com.

You are free to use any of the code samples as you see fit, in both 
public and private projects. However, please do not share any other
content from this article publicly without my permission.
