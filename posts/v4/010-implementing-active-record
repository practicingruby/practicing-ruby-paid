> This two part series explores the challenges involved in
> building a minimal implementation of the Active Record pattern. 
> [Issue 4.8](http://practicingruby.com/articles/60) provides
> some basic background information of the problem and
> walks through some of the low level structures that are
> needed to build an ORM. This issue builds on top of
> those structures to construct a complete Active Record
> object.

### Building object-oriented mixins

One thing that makes the Active Record pattern challenging to implement is that
involves shoehorning a bunch of persistence-related functionality into model
objects. In the case of Rails, models inherit from `ActiveRecord::Base` which
has dozens of modules mixed into it. This inheritance-based approach is the
common way of doing complex behavior sharing in Ruby, but comes at a [high
maintainence cost](http://practicingruby.com/articles/62). This is one of the
main design challenges that
[BrokenRecord](https://github.com/elm-city-craftworks/broken_record) attempts to solve.

Because this is a tricky problem, it helps to explore the ideas by
solving an easier problem first. For example, suppose that you have the following trivial
`Stack` object and you want to extend it with some `Enumerable`-like
functionality without mixing `Enumerable` into the `Stack` object itself:

```ruby
class Stack
  def initialize
    @data = []
  end

  def push(obj)
    data.push(obj)
  end

  def pop
    data.pop
  end

  def size
    data.size
  end

  def each
    data.reverse_each { |e| yield(e) }
  end

  private

  attr_reader :data
end
```

You could use an `Enumerator` for this purpose, as shown in the following
example:

```ruby
stack = Stack.new

stack.push(10)
stack.push(20)
stack.push(30)

enum  = Enumerator.new { |y| stack.each { |e| y.yield(e) } }
p enum.map { |x| "Has element: #{x}" } #=~
# ["Has element: 30", "Has element: 20", "Has element: 10"]    
```

This is a very clean design, but it makes it so that you have to interact with
both a `Stack` object and an `Enumerator`, which feels a bit tedious. With a
little effort, the two could be unified under a single interface while keeping
their variables and internal method calls separated:

```ruby
class EnumerableStack
  def initialize
    @stack = Stack.new
    @enum  = Enumerator.new { |y| @stack.each { |e| y.yield(e) } }       
  end

  def respond_to_missing?(m, *a)
    [@stack, @enum].find { |e| e.respond_to?(m) }
  end

  def method_missing(m, *a, &b)
    obj = respond_to_missing?(m)

    return super unless obj
    obj.send(m, *a, &b)
  end
end
```

From the external perspective, `EnumerableStack` still looks and 
feels like an ordinary `Enumerable` object:

```ruby
stack = EnumerableStack.new

stack.push(10)
stack.push(20)
stack.push(30)

p stack.map { |x| "Has element: #{x}" } #=~
# ["Has element: 30", "Has element: 20", "Has element: 10"]  
```

Unfortunately, it is painful to implement objects this way. If you
applied this kind of technique throughout your codebase without introducing some
sort of abstraction, you would find yourself writing a ton of very boring
`respond_to_missing?` and `method_missing` calls. It would be better to have
an object that knows how to delegate methods for you, such as the `Composite`
object in the following example:

```ruby
class EnumerableStack
  def initialize
    stack = Stack.new
    enum  = Enumerator.new { |y| stack.each { |e| y.yield(e) } }      
    
    @composite = Composite.new
    @composite << stack << enum
  end

  def respond_to_missing?(m, *a)
    @composite.handle?(m)
  end

  def method_missing(m, *a, &b)
    @composite.dispatch(m, *a, &b)
  end
end
```

The neat thing about this approach is that the `EnumerableStack`
object now only needs to keep track of a single variable, even though it is
delegating to multiple objects. This makes it safe to extract some
of the functionality into a mix-in without the code becoming too brittle:

```ruby
class EnumerableStack
  include Composable

  def initialize
    stack = Stack.new
    enum  = Enumerator.new { |y| stack.each { |e| y.yield(e) } }      

    features << stack << enum
  end
end
```

The end result looks pretty clean, but using the `Composable` 
mixin to solve this particular problem is massively overkill. 
Mixing the `Enumerable` module directly into the `Stack` object
is not that hard to do, and is unlikely to have any adverse
consequences. Still, seeing how `Composable` can be used to
replace one of the most common applications of mixins 
hopefully gave you a better understanding of how it 
can be applied in more complex scenarios. The good news is 
that as long as you have a rough idea of how `Composable` 
works in this context, you will have no trouble understanding
how it is used in BrokenRecord.

To test whether or not you understand the basic pattern, take a look at the
following code and see if you can piece together how it works. Don't worry about
the exact implementation details, just compare the following code to the other
examples in this section and think about what the purpose of this module is:

```ruby
module BrokenRecord
  module Mapping
    include Composable

    def initialize(params)
      features << Record.new(params)
    end

    def self.included(base)
      base.extend(ClassMethods)
    end

    module ClassMethods
      include Composable

      def map_to_table(table_name)
        features << Relation.new(:name         => table_name,
                                 :db           => BrokenRecord.database,
                                 :record_class => self)
      end
    end
  end
end
```

If you guessed that mixing this module into one of your own classes will expose 
the methods provided by `BrokenRecord::Relation` as class methods, and the methods
provided by `BrokenRecord::Record` as instance methods, then you guessed
correctly! If you're still stuck, recall how this mixin is used:

```ruby
class Article
  include BrokenRecord::Mapping

  map_to_table :articles
end

article = Article.create(:title => "Great article", :body => "Wonderful!")
p article.title.upcase #=> "GREAT ARTICLE"
```

If you consider that the definition of `BrokenRecord::Mapping` above is its
complete implementation, it becomes clear that the methods being called in this
example need to come from somewhere. Now, it should be easier to see that
`Relation` and `Record` are where those methods come from.

You really don't need to know the exact details of how 
the `Composable` module works, because it is built based entirely on the 
ideas already discussed in this article. However, if `Composable` still feels
magical to you, go ahead and [study its
implementation](https://github.com/elm-city-craftworks/broken_record/blob/master/lib/broken_record/composable.rb)
before reading on. For bonus points, pull the code down and try to 
recreate the `EnumerableStack` example on your own machine.

Once you feel that you have a good grasp on how `Composable` works, you can
continue on to see how it can be used to implement an Active Record object.

### Implementing relations as an object-oriented mixin 

EXPERIMENT WITH TELLING THIS STORY FROM THE PERSPECTIVE OF THE CALLS,

Article.find(1) #=> article <-- what has to happen for this all to work?

At its heart, `BrokenRecord::Relation` is nothing more than a factory
object that connects user-defined record objects with the low 
level `BrokenRecord::Table` database interface. You can navigate your 
way through a few examples to learn exactly how it works.

To keep things simple, you can start with an ordinary class definition, and note
that it does not mix in the `BrokenRecord::Mapping` module or include any other
third party code:

```ruby
class Article
  def initialize(params)
    @params = params
  end

  def to_s
    "TITLE: #{@params[:values][:title]}\n"+
    "BODY:  #{@params[:values][:body]}"
  end
end
```

From here, it is possible to tie this class to a database table and get some
Active Record style functionality for querying and inserting data:

```ruby
# a factory for record objects that interacts with Table
articles = BrokenRecord::Relation.new(:record_class => Article,
                                      :name         => "articles")

articles.create(:title => "A great article",
                :body  => "Short but sweet")

articles.create(:title => "A not so great article",
                :body  => "Just as short")


puts articles.all.join("\n\n") #=~
# TITLE: A great article
# BODY:  Short but sweet
#
# TITLE: A not so great article
# BODY:  Just as short
```

If you take a look at how `BrokenRecord::Relation` is defined, you will see that
it does not implement much functionality on its own; much of its work is 
delegated to `Relation::CRUD` and `Relation::Associations`:

```ruby
module BrokenRecord
  class Relation
    include Composable

    def initialize(params)
      self.table = Table.new(:name => params.fetch(:name),
                             :db   => BrokenRecord.database)

      self.record_class = params.fetch(:record_class)

      features << CRUD.new(self) << Associations.new(self)
    end

    attr_reader :table, :record_class
    
    # ...

    private

    attr_writer :table, :record_class
  end
end
```

That said, `BrokenRecord::Relation` does create an instance of
`BrokenRecord::Table` and keeps a reference to a record class
which can later be used to wrap the data that comes back from
the database. This information gets injected into 
`Relation::CRUD` and `Relation::Association` so that they can 
build their own functionality on top of it.

If you take a closer look at how `BrokenRecord::Relation` is 
being used here, it is easy to see that it is doing simple CRUD 
operations. In particular, the example makes calls to 
the `#create` and `#all` methods:

```ruby
articles = BrokenRecord::Relation.new(:record_class => Article,
                                      :name         => "articles")

articles.create(:title => "A great article",
                :body  => "Short but sweet")

articles.create(:title => "A not so great article",
                :body  => "Just as short")

puts articles.all.join("\n\n") #=~ ...
```

If you don't remember how `BrokenRecord::Table` works, now might be a good time
to skim through [Issue 4.8](http://practicingruby.com/articles/60) 
again and refresh your memory. But regardless of whether you are familiar with
the details of how it works or not, it should be fairly obvious that the
following code is just a thin veneer layered on top of `BrokenRecord::Table`
which wraps results by creating instances of the provided record class:


```ruby
module BrokenRecord
  class Relation
    class CRUD
      def initialize(relation)
        self.relation = relation
      end

      # ...

      def create(values)
        id = table.insert(values)    
      
        find(id)
      end

      def find(id)
        values = table.where(table.primary_key => id).first

        return nil unless values

        record_class.new(:relation => relation,
                         :values   => values,
                         :key      => id)
      end

      def all
        table.all.map do |values| 
          record_class.new(:relation  => relation,
                           :values    => values,
                           :key       => values[table.primary_key])
        end
      end

      private

      attr_accessor :relation

      def table
        relation.table
      end

      def record_class
        relation.record_class
      end
    end
  end
end
```

Leave associations as an exercise for the reader?
"Same basic idea, just with more meta-programming"

### Implementing records as an object-oriented mixin


```ruby
class Article
  include BrokenRecord::Mapping

  def to_s
    "TITLE: #{title}\n"+
    "BODY:  #{body}"
  end
end

Article.create(:title => "A great article",
               :body  => "Short but sweet")

Article.create(:title => "A not so great article",
               :body  => "Just as short")

puts Article.all.join("\n\n")
```

### Reflections

The idea of object-oriented mixins seems very promising to me, but also full of
open questions and potential pitfalls. While they seem to work well in this toy
implementation of Active Record, they may end up creating as many problems as
they solve. In particular, it remains to be seen how this kind of modeling would
impact performance, debugging, and introspection of Ruby objects. Still, the
pattern does a good enough job of simplifying a very complex architectural
pattern to hint that some further experimentation may be worthwhile.

Going back to the original question I had hoped to answer in this two part
article about whether or not the Active Record pattern is inherently complex, I
suppose we have found out that there isn't an easy answer to that question. My
BrokenRecord implementation is conceptually simpler than the Rails-based
ActiveRecord, but only implements a tiny amount of functionality. I think that
the closest thing to a conclusion I can come to here is that the traditional
methods we use for object modeling in Ruby are certainly complex, and so any
system which attempts to implement large-scale architectural patterns in Ruby
will inherit that complexity unless it deviates from convention.

That all having been said, reducing complexity is about  more than just
preferring composition over inheritance and reducing the amount of magic in our
code. The much deeper questions that we can ask ourselves is whether these very
complicated systems we build are really necessary, or if they are a
consequence of piling [abstractions on top of abstractions](http://timelessrepo.com/abstraction-creep) 
in order to fixing some fundamental low-level problem.

While this two-part article was a fun little exploration into the depths of a
complex modeling problem in Ruby, I think its real point is to get us to
question our own tolerance for complexity at all levels of what we do. If you
have thoughts to share about that, I would love to hear them.
